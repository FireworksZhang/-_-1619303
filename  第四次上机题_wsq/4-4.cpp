#define _CRT_SECURE_NO_WARNINGS
///////////////////////////////////////////////////////////////////////////////////////////////////
//	请实现一个铁路购票系统的简单座位分配算法，来处理一节车厢的座位分配。
//	假设一节车厢有20排、每一排5个座位。为方便起见，我们用1到100来给所有的座位编号，第一排是1到5号，第二排是6到10号，依次类推，第20排是96到100号。
//	购票时，一个人可能购一张或多张票，最多不超过5张。如果这几张票可以安排在同一排编号相邻的座位，则应该安排在编号最小的相邻座位。否则应该安排在编号最小的几个空座位中（不考虑是否相邻）。
//	假设初始时车票全部未被购买，现在给了一些购票指令，请你处理这些指令。
//	输入格式：对于所有评测用例，1 ≤ n ≤ 100，所有购票数量之和不超过100。
//	输入的第一行包含一个整数n，表示购票指令的数量。
//	第二行包含n个整数，每个整数p在1到5之间，表示要购入的票数，相邻的两个数之间使用一个空格分隔。
//	输出格式：输出n行，每行对应一条指令的处理结果。
//	对于购票指令p，输出p张车票的编号，按从小到大排序。
//	问题分析：这个问题可以用顺序结构或链式结构实现。
//
//	样例输入
//	4
//	2 5 4 2
//	样例输出
//	1 2
//	6 7 8 9 10
//	11 12 13 14
//	3 4
///////////////////////////////////////////////////////////////////////////////////////////////////

#include<stdio.h>
#include<stdlib.h>

int main()
{
	int i, j, n, m, t, row[20] = { 0 };
	scanf("%d", &n);
	for (i = 0; i < n; i++) {
		t = 0;
		scanf("%d", &m);
		for (j = 0; j < 20; j++) 
			if (row[j] <= 5 - m) {
				while (t < m) {
					printf("%d ", j * 5 + (++row[j]));
					t++;
				}
				break;
			}
		if (j == 20) 
			for (j = 0; j < 20; j++)
				if (row[j] < 5)
					while (row[j] < 5 && t < m) {
						printf("%d ", j * 5 + (++row[j]));
						t++;
					}
		printf("\n");
	}//for i
	system("PAUSE");
}