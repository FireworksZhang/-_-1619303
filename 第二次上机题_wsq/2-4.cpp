#define _CRT_SECURE_NO_WARNINGS
///////////////////////////////////////////////////////////////////////////////////////////////////
//	小明在他的果园里种了一些苹果树，这些苹果树排列成一个圆。为了保证苹果的品质，在种植过程中要进行疏果操作。为了更及时地完成疏果操作，小明会不时地检查每棵树的状态，根据需要进行疏果。
//	检查时，如果发现可能有苹果从树上掉落，小明会重新统计树上的苹果个数（然后根据之前的记录就可以判断是否有苹果掉落了)。在全部操作结束后，请帮助小明统计相关的信息。
//
//	输入格式：
//	第1行包含一个正整数N，表示苹果树的棵数。
//	第1 + i行（1≤i≤N)，每行的格式为mi, ai1, ai2, ..., aimi, 。其中，第一个正整数mi表示本行后面的整数个数。后续的mi个整数表示小明对第i棵苹果树的操作记录。若aij(1≤ j ≤mi）为正整数，则表示小明进行了重新统计该棵树上的苹果个数的操作，统计的苹果个数为aij; 若为零或负整数，则表示一次疏果操作，去掉的苹果个数是 | aij | 。
//	输入保证一定是正确的，满足 :
//	a.ai1 > 0，即对于每棵树的记录，第一个操作一定是统计苹果个数（初始状态，此时不用判断是否有苹果掉落）；
//	b.每次疏果操作保证操作后树上的苹果个数仍为正。
//
//	输出格式：
//	输出只有一行，包含三个整数T、D、E。其中，
//	a.T为全部疏果操作结束后所有苹果树上剩下的苹果总数（假设每棵苹果树在最后一次统计苹果个数操作后苹果不会因为疏果以外的原因减少);
//	b.D为发生苹果掉落的苹果树的棵数;
//	c.E为相邻连续三棵树发生苹果掉落情况的组数。
//	对于第三个统计量的解释：N棵苹果树A1, A2, ..., AN排列成一个圆，那么A1与A2相邻，A2与A3相邻，......，AN - 1与AN相邻，AN与A1相邻。
//	如果Ai - 1, Ai，Ai + 1这三棵树都发生了苹果掉落的情况，则记为一组。形式化的，有	E = | {Ai / Drop(Pred(Ai)）∧Drop(Ai）∧Drop(Succ(Ai)）} |
//	其中，Drop(Ai）表示苹果树Ai是否发生苹果掉落的情况，Pred(Ai)表示Ai的前一棵树Ai - 1（如果i > 1）或者AN（如果i = 1)，Succ(Ai)表示Ai的后一棵树Ai + 1（如果i < N）或者A1（如果i = N）
//	
//	样例1输入：
//	4
//	4 74 - 7 - 12 - 5
//	5 73 - 8 - 6 59 - 4
//	5 76 - 5 - 10 60 - 2
//	5 80 - 6 - 15 59 0
//	样例1输出：
//	222 1 0
//	样例1解释：全部操作结束后，第1棵树上剩下的苹果个数为74 - 7 - 12 - 5 = 50，第2棵为59 - 4 = 55，第3棵为60 - 2 = 58，第4棵为59 - 0 = 59。因此T = 50 + 55 + 58 + 59 = 222。其中，第3棵树在第2次统计之前剩下的苹果个数为76 - 5 - 10 = 61>60，因此发生了苹果掉落的情况。可以检验其他的树没有这种情况，因此D = 1。没有连续三棵树都发生苹果掉落的情况，因此E = 0。
//	
//	样例2输入：
//	5
//	4 10 0 9 0
//	4 10 - 2 7 0
//	2 10 0
//	4 10 - 3 5 0
//	4 10 - 1 8 0
//	样例2输出：
//	39 4 2
//	样例2解释：第1、2、4、5棵树发生了苹果掉落的情况，因此D = 4。其中，连续三棵树都发生苹果掉落情况的有(5, 1, 2)和(4, 5, 1)，因此E = 2。
///////////////////////////////////////////////////////////////////////////////////////////////////

#include<stdio.h>
#include<stdlib.h>

int main()
{
	int n, m, a, i, j, t, *d, T, D, E;
	T = 0;
	D = 0;
	E = 0;
	scanf("%d", &n);
	d = (int *)malloc(sizeof(int) * n);
	for (i = 0; i < n; i++) {
		scanf("%d", &m);
		scanf("%d", &d[i]);
		t = d[i];
		for (j = 1; j < m; j++) {
			scanf("%d", &a);
			if (a > 0)	//重新统计树上的苹果个数
				t = a;
			else {		//疏果操作
				t += a;
				d[i] += a;
			}
		}//for j
		T += t;
		if (d[i] > t)
			d[i] = 1;
		else
			d[i] = 0;
	}//for i

	j = 0;
	for (i = 0; i < n; i++) {
		if (d[i] == 0)
			j = 0;
		else {
			D++;
			j++;
			if (j == 3) {
				E++;
				j--;
			}
		}
	}
	for (i = 0; i < 2; i++) {
		if (d[i] == 0)
			j = 0;
		else {
			j++;
			if (j == 3) {
				E++;
				j--;
			}
		}
	}

	printf("%d %d %d", T, D, E);

	system("PAUSE");

}

